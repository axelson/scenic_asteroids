/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.mjs":
/*!***********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.mjs ***!
  \***********************************************/
/*! exports provided: Channel, LongPoll, Presence, Serializer, Socket */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Channel\", function() { return Channel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LongPoll\", function() { return LongPoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Presence\", function() { return Presence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return serializer_default; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Socket\", function() { return Socket; });\n// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || global;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n    return req;\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => callback && callback(null);\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n    return req;\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.reqs = /* @__PURE__ */ new Set();\n    this.awaitingBatchAck = false;\n    this.currentBatch = null;\n    this.currentBatchTimer = null;\n    this.batchBuffer = [];\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry(code, reason, wasClean) {\n    this.close(code, reason, wasClean);\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry(1005, \"timeout\", false);\n  }\n  isActive() {\n    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;\n  }\n  poll() {\n    this.ajax(\"GET\", \"application/json\", null, () => this.ontimeout(), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => this.onmessage({ data: msg }), 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen({});\n          this.poll();\n          break;\n        case 403:\n          this.onerror(403);\n          this.close(1008, \"forbidden\", false);\n          break;\n        case 0:\n        case 500:\n          this.onerror(500);\n          this.closeAndRetry(1011, \"internal server error\", 500);\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    if (this.currentBatch) {\n      this.currentBatch.push(body);\n    } else if (this.awaitingBatchAck) {\n      this.batchBuffer.push(body);\n    } else {\n      this.currentBatch = [body];\n      this.currentBatchTimer = setTimeout(() => {\n        this.batchSend(this.currentBatch);\n        this.currentBatch = null;\n      }, 0);\n    }\n  }\n  batchSend(messages) {\n    this.awaitingBatchAck = true;\n    this.ajax(\"POST\", \"application/x-ndjson\", messages.join(\"\\n\"), () => this.onerror(\"timeout\"), (resp) => {\n      this.awaitingBatchAck = false;\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry(1011, \"internal server error\", false);\n      } else if (this.batchBuffer.length > 0) {\n        this.batchSend(this.batchBuffer);\n        this.batchBuffer = [];\n      }\n    });\n  }\n  close(code, reason, wasClean) {\n    for (let req of this.reqs) {\n      req.abort();\n    }\n    this.readyState = SOCKET_STATES.closed;\n    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });\n    this.batchBuffer = [];\n    clearTimeout(this.currentBatchTimer);\n    this.currentBatchTimer = null;\n    if (typeof CloseEvent !== \"undefined\") {\n      this.onclose(new CloseEvent(\"close\", opts));\n    } else {\n      this.onclose(opts);\n    }\n  }\n  ajax(method, contentType, body, onCallerTimeout, callback) {\n    let req;\n    let ontimeout = () => {\n      this.reqs.delete(req);\n      onCallerTimeout();\n    };\n    req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {\n      this.reqs.delete(req);\n      if (this.isActive()) {\n        callback(resp);\n      }\n    });\n    this.reqs.add(req);\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimeoutTimer = null;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  getLongPollTransport() {\n    return LongPoll;\n  }\n  replaceTransport(newTransport) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.sendBuffer = [];\n    if (this.conn) {\n      this.conn.close();\n      this.conn = null;\n    }\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.connectClock++;\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  ping(callback) {\n    if (!this.isConnected()) {\n      return false;\n    }\n    let ref = this.makeRef();\n    let startTime = Date.now();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref });\n    let onMsgRef = this.onMessage((msg) => {\n      if (msg.ref === ref) {\n        this.off([onMsgRef]);\n        callback(Date.now() - startTime);\n      }\n    });\n    return true;\n  }\n  clearHeartbeats() {\n    clearTimeout(this.heartbeatTimer);\n    clearTimeout(this.heartbeatTimeoutTimer);\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.triggerChanError();\n      this.closeWasClean = false;\n      this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, \"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    this.clearHeartbeats();\n    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onopen = function() {\n          };\n          this.conn.onerror = function() {\n          };\n          this.conn.onmessage = function() {\n          };\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    this.clearHeartbeats();\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.clearHeartbeats();\n        this.pendingHeartbeatRef = null;\n        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\n\n//# sourceMappingURL=phoenix.mjs.map\n\n\n//# sourceURL=webpack:///../deps/phoenix/priv/static/phoenix.mjs?");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        submit = document.createElement(\"input\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"none\";\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form); // Insert a button and click it instead of using `form.submit`\n    // because the `submit` function does not emit a `submit` event.\n\n    submit.type = \"submit\";\n    form.appendChild(submit);\n    submit.click();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n    if (e.defaultPrevented) return;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n\n//# sourceURL=webpack:///../deps/phoenix_html/priv/static/phoenix_html.js?");

/***/ }),

/***/ "./css/app.css":
/*!*********************!*\
  !*** ./css/app.css ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./css/app.css?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./css/app.css\");\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket.js */ \"./js/socket.js\");\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./game.js */ \"./js/game.js\");\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_game_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main.js */ \"./js/main.js\");\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import dependencies\n//\n\n // Import local files\n\n\n\n\nObject(_main_js__WEBPACK_IMPORTED_MODULE_4__[\"start\"])(_socket_js__WEBPACK_IMPORTED_MODULE_2__[\"socket\"], _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"lobbyChannel\"]);\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/game.js":
/*!********************!*\
  !*** ./js/game.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var scaleFactor = 0.6;\nvar gameWidth = 800 * scaleFactor;\nvar gameHeight = 350 * scaleFactor;\nvar config = {\n  type: Phaser.AUTO,\n  width: gameWidth,\n  height: gameHeight,\n  scale: {\n    mode: Phaser.Scale.FIT\n  },\n  physics: {\n    \"default\": 'arcade',\n    arcade: {\n      gravity: {\n        y: 200\n      }\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\nvar cursors;\nvar keys;\nvar arrows;\nvar game;\nvar shooting = false; // Circle location is used to calculate the angle for firing\n\nvar arrowBaseX = 100;\nvar arrowBaseY = 100;\nvar circleX = 350;\nvar circleY = 100;\n\nwindow.onCreateGame = function () {\n  game = new Phaser.Game(config);\n  window.game = game;\n};\n\nfunction preload() {\n  this.load.image('arrow', '/images/arrow.png');\n}\n\nfunction create() {\n  arrows = this.physics.add.staticGroup();\n  createArrows(arrows);\n  this.input.on('gameobjectdown', function (pointer, gameObject) {\n    if (isArrow(gameObject)) {\n      var direction = arrowToDirection(gameObject);\n      console.log(\"send\", direction);\n      sendSetDirection(direction);\n    } else {\n      console.log(\"clicked on\", gameObject.name);\n    }\n  });\n  this.input.on('gameobjectup', function (pointer, gameObject) {\n    if (isArrow(gameObject)) {\n      var direction = arrowToDirection(gameObject);\n      console.log(\"done\", direction);\n      sendClearDirection(direction);\n    }\n  });\n  cursors = this.input.keyboard.createCursorKeys();\n  keys = {};\n  var graphics = this.add.graphics({\n    fillStyle: {\n      color: 0x00ff00\n    }\n  });\n  var circle = new Phaser.Geom.Circle(circleX, circleY, 15);\n\n  function drawCircle() {\n    graphics.fillCircleShape(circle);\n  }\n\n  drawCircle(graphics, circle);\n  this.input.on('pointerdown', function (pointer) {\n    console.log('down!');\n    var touchX = pointer.x;\n    var touchY = pointer.y;\n    console.log(\"x: \".concat(touchX, \" y:\").concat(touchY));\n    var relX = touchX - circleX;\n    var relY = touchY - circleY; // Only shoot if the touch is near the circle (ideally this area would be a\n    // circle but it isn't really that important)\n\n    if (Math.abs(relX) < 100 && Math.abs(relY) < 100) {\n      shooting = true;\n      sendShootDirection(relX, -relY);\n    }\n  });\n  this.input.on('pointerup', function (pointer) {\n    if (shooting) {\n      shooting = false;\n      clearShooting();\n    }\n  });\n  this.input.keyboard.on('keydown-SPACE', function (event) {\n    sendShoot();\n  });\n  this.input.keyboard.on('keyup-SPACE', function (event) {\n    clearShooting();\n  });\n  var that = this;\n  this.input.keyboard.on('keydown-F', function (event) {\n    if (that.scale.isFullscreen) {\n      that.scale.stopFullscreen();\n    } else {\n      that.scale.startFullscreen();\n    }\n  });\n  this.input.keyboard.on('keydown-Q', function (event) {\n    window.onRotateLeft();\n  });\n  this.input.keyboard.on('keyup-Q', function (event) {\n    window.onClearRotateLeft();\n  });\n  this.input.keyboard.on('keydown-E', function (event) {\n    window.onRotateRight();\n  });\n  this.input.keyboard.on('keyup-E', function (event) {\n    window.onClearRotateRight();\n  });\n  this.input.keyboard.on('keydown', function (event) {\n    var direction = keyToDirection(event.key);\n\n    if (direction) {\n      sendSetDirection(direction);\n    }\n  });\n  this.input.keyboard.on('keyup', function (event) {\n    var direction = keyToDirection(event.key);\n\n    if (direction) {\n      sendClearDirection(direction);\n    }\n  });\n}\n\nfunction arrowToDirection(gameObject) {\n  switch (gameObject.name) {\n    case 'right-arrow':\n      return 'right';\n\n    case 'down-arrow':\n      return 'down';\n\n    case 'left-arrow':\n      return 'left';\n\n    case 'up-arrow':\n      return 'up';\n\n    default:\n      return false;\n  }\n}\n\nfunction isArrow(gameObject) {\n  return ['right-arrow', 'down-arrow', 'left-arrow', 'up-arrow'].indexOf(gameObject.name) !== -1;\n}\n\nfunction createArrows() {\n  var offset = 50;\n  var rightArrow = arrows.create(arrowBaseX + offset, arrowBaseY, 'arrow').setInteractive();\n  rightArrow.name = \"right-arrow\";\n  var downArrow = arrows.create(arrowBaseX, arrowBaseY + offset, 'arrow').setInteractive();\n  downArrow.name = \"down-arrow\";\n  downArrow.angle = 90;\n  var leftArrow = arrows.create(arrowBaseX - offset, arrowBaseY, 'arrow').setInteractive();\n  leftArrow.name = \"left-arrow\";\n  leftArrow.angle = 180;\n  var upArrow = arrows.create(arrowBaseX, arrowBaseY - offset, 'arrow').setInteractive();\n  upArrow.name = \"up-arrow\";\n  upArrow.angle = 270;\n} // game.input.addPointer(3);\n\n\nfunction recordDirection(direction) {\n  // Need to keep track of if this key is currently pressed so we know when it\n  // transitions\n  if (!keys[direction]) {\n    console.log(\"recording direction: \".concat(direction));\n    keys[direction] = true;\n    sendSetDirection(direction);\n  }\n}\n\nfunction unRecordDirection(direction) {\n  if (keys[direction]) {\n    keys[direction] = false;\n    console.log('unrecord ' + direction);\n    sendClearDirection(direction);\n  }\n}\n\nfunction sendSetDirection(direction) {\n  window.onDirection(direction);\n}\n\nfunction sendClearDirection(direction) {\n  window.onClearDirection(direction);\n}\n\nfunction sendShoot() {\n  window.onSendShoot();\n}\n\nfunction sendShootDirection(relX, relY) {\n  window.onSendShootDirection(relX, relY);\n}\n\nfunction clearShooting() {\n  window.onClearShooting();\n}\n\nfunction update() {\n  // console.log('update!')\n  // console.log(\"keys\", keys);\n  // console.log(\"cursors.left\", cursors.left)\n  // TODO: Use this to periodically send the orientation of the ship\n  // var pointer = game.input.activePointer;\n  // if (pointer.isDown) {\n  //   var touchX = pointer.x;\n  //   var touchY = pointer.y;\n  //   console.log(`x: ${touchX} y:${touchY}`);\n  //   var relX = arrowBaseX - touchX;\n  //   var relY = arrowBaseY - touchY;\n  //   console.log(`relX: ${relX} relY: ${relY}`)\n  // }\n  // console.log(\"cursors.left.isDown\", cursors.left.isDown);\n  // console.log(\"cursors.right.isDown\", cursors.right.isDown);\n  // console.log(\"cursors.up.isDown\", cursors.up.isDown);\n  // console.log(\"cursors.down.isDown\", cursors.down.isDown);\n  if (cursors.left.isDown) {\n    recordDirection('left');\n  } else {\n    unRecordDirection('left');\n  }\n\n  if (cursors.up.isDown) {\n    recordDirection('up');\n  } else {\n    unRecordDirection('up');\n  }\n\n  if (cursors.right.isDown) {\n    recordDirection('right');\n  } else {\n    unRecordDirection('right');\n  }\n\n  if (cursors.down.isDown) {\n    recordDirection('down');\n  } else {\n    unRecordDirection('down');\n  }\n}\n\nfunction keyToDirection(key) {\n  switch (key) {\n    case 'w':\n      return 'up';\n\n    case 'a':\n      return 'left';\n\n    case 's':\n      return 'down';\n\n    case 'd':\n      return 'right';\n\n    default:\n      return null;\n  }\n}\n\n//# sourceURL=webpack:///./js/game.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! exports provided: start */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\nconsole.log(\"main\");\n\nfunction bindJason() {\n  var loginForm = document.getElementById(\"login-form\");\n  var usernameInput = document.getElementById(\"username-input\");\n  var jasonLoginBtn = document.getElementById(\"jason-login-btn\");\n\n  if (jasonLoginBtn) {\n    jasonLoginBtn.addEventListener(\"click\", function (e) {\n      console.log(\"logging in as jason\");\n      e.preventDefault();\n      usernameInput.value = \"jason\";\n      loginForm.submit();\n    });\n  }\n}\n\nvar started = false;\nfunction start(socket, lobbyChannel) {\n  bindJason();\n  jQuery('#fullscreen-button').on('click', function (e) {\n    if (window.game.scale.isFullscreen) {\n      window.game.scale.stopFullscreen();\n    } else {\n      window.game.scale.startFullscreen();\n    }\n  });\n  lobbyChannel.on('game_start', function () {\n    if (!started) {\n      window.onCreateGame();\n      jQuery('#waiting-message').hide();\n      jQuery('#player-instructions').show();\n      jQuery('#fullscreen-button').show();\n    }\n\n    started = true;\n    lobbyChannel.push('request_player_color', {});\n  });\n  lobbyChannel.on('player_color', function (msg) {\n    console.log(\"msg\", msg);\n    jQuery('#player-color-value').text(msg.color).css({\n      color: cssColor(msg.color)\n    });\n    jQuery('#player-color').show();\n  });\n  lobbyChannel.onClose(function () {\n    console.log('channel closed!');\n  });\n  lobbyChannel.onError(function (e) {\n    console.log(\"lobby channel error\", e);\n  });\n  socket.onOpen(function () {\n    jQuery('#disconnected-message').hide();\n  });\n  socket.onError(function (e) {\n    if (socket.isConnected()) {\n      jQuery('#disconnected-message').hide();\n    } else {\n      jQuery('#disconnected-message').show();\n    }\n  });\n}\n\nfunction cssColor(color) {\n  switch (color) {\n    case \"orange_red\":\n      return \"orangered\";\n\n    case \"powder_blue\":\n      return \"powderblue\";\n\n    default:\n      return color;\n  }\n}\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./js/socket.js":
/*!**********************!*\
  !*** ./js/socket.js ***!
  \**********************/
/*! exports provided: socket, lobbyChannel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"socket\", function() { return socket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lobbyChannel\", function() { return lobbyChannel; });\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.mjs\");\n\nvar socket = new phoenix__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"](\"/socket\", {\n  params: window.SocketExports\n});\nvar lobbyChannel;\n\nif (document.querySelector('#game')) {\n  socket.connect();\n  lobbyChannel = socket.channel(\"lobby\", window.SocketExports);\n\n  var onJoin = function onJoin(resp) {\n    console.log(\"Joined!\", resp);\n  };\n\n  window.onDirection = function (direction) {\n    direction = determineDirection(direction);\n    console.log(\"Send direction: \".concat(direction));\n    lobbyChannel.push(\"player_direction\", {\n      direction: direction\n    });\n  };\n\n  window.onClearDirection = function (direction) {\n    direction = determineDirection(direction);\n    lobbyChannel.push(\"clear_player_direction\", {\n      direction: direction\n    });\n  };\n\n  window.onSendShoot = function () {\n    lobbyChannel.push(\"try_shoot\", {});\n  };\n\n  window.onSendShootDirection = function (relX, relY) {\n    var obj = {\n      x: relX,\n      y: relY\n    };\n    console.log(\"obj\", obj);\n    lobbyChannel.push(\"try_shoot_direction\", obj);\n  };\n\n  window.onClearShooting = function () {\n    lobbyChannel.push('clear_shooting', {});\n  };\n\n  window.onRotateLeft = function () {\n    console.log(\"rot left!\");\n    lobbyChannel.push('rotate_left', {});\n  };\n\n  window.onClearRotateLeft = function () {\n    lobbyChannel.push('clear_rotate_left', {});\n  };\n\n  window.onRotateRight = function () {\n    lobbyChannel.push('rotate_right', {});\n  };\n\n  window.onClearRotateRight = function () {\n    lobbyChannel.push('clear_rotate_right', {});\n  };\n\n  if (window.SocketExports) {\n    lobbyChannel.join().receive(\"ok\", onJoin).receive(\"error\", function (resp) {\n      var reason = resp[\"reason\"];\n      console.log(\"Unable to join: \".concat(reason));\n      alert(\"Unable to join: \".concat(reason));\n    });\n  }\n} else {\n  console.warn(\"unable to find #game div!\");\n}\n\nfunction determineDirection(direction) {\n  switch (direction) {\n    case \"left\":\n      return \"left\";\n\n    case \"up\":\n      return \"up\";\n\n    case \"right\":\n      return \"right\";\n\n    case \"down\":\n      return \"down\";\n\n    default:\n      throw \"unhandled direction \".concat(direction);\n  }\n}\n\n\n\n//# sourceURL=webpack:///./js/socket.js?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js?");

/***/ })

/******/ });